shader_type canvas_item;
render_mode blend_premul_alpha;

// ───────── Visual controls ─────────
uniform float Angle_deg : hint_range(-90.0, 90.0) = 30.0;   // base band angle (degrees)
uniform float Brightness : hint_range(0.0, 5.0) = 2.5;      // white intensity added over sprite

// Feather (softness). Set to 0.0 for hard edges.
uniform float Band_Soft  : hint_range(0.0, 0.3) = 0.06;

// ───────── Staging controls ─────────
// 1, 2, or 3 sweeps per cycle
uniform int   Stage_Count : hint_range(1, 3) = 2;

// Per-stage durations (seconds). Only the first N are used (N = Stage_Count).
uniform float Stage1_Duration : hint_range(0.01, 10.0) = 1.0;
uniform float Stage2_Duration : hint_range(0.01, 10.0) = 1.5;
uniform float Stage3_Duration : hint_range(0.01, 10.0) = 1.0;

// Per-stage band widths (UV units). Only the first N are used.
uniform float Stage1_Width : hint_range(0.0, 0.5) = 0.12;
uniform float Stage2_Width : hint_range(0.0, 0.5) = 0.12;
uniform float Stage3_Width : hint_range(0.0, 0.5) = 0.12;

// Per-stage direction toggles (true = left→right; false = right→left)
uniform bool Stage1_LeftToRight = true;
uniform bool Stage2_LeftToRight = false; // default opposite for variation
uniform bool Stage3_LeftToRight = true;

// ───────── Animation mode ─────────
// Loop → continuous; One_Shot → plays full cycle once (optional delay) then stays off.
uniform bool  One_Shot = false;
uniform float OneShot_Delay : hint_range(0.0, 10.0) = 0.0;

// Loop phase offset (0..1 across the entire multi-stage cycle)
uniform float Phase_Offset : hint_range(0.0, 1.0) = 0.0;

// ───────── NEW: Angle wiggle during sweep ─────────
// Enable to vary angle by ±Wiggle_Amount_deg over the stage progress.
uniform bool  Wiggle_Angle = false;
uniform float Wiggle_Amount_deg : hint_range(0.0, 45.0) = 15.0;

// Rotate UVs around center
vec2 rotate_uv(vec2 uv, vec2 center, float deg){
    float a = radians(deg);
    mat2 r = mat2(vec2(cos(a), -sin(a)), vec2(sin(a), cos(a)));
    return r * (uv - center) + center;
}

void fragment() {
    // 1) Base sprite color
    vec4 base = texture(TEXTURE, UV);

    // 2) Stage timings
    float T1 = max(1e-4, Stage1_Duration);
    float T2 = (Stage_Count >= 2) ? max(1e-4, Stage2_Duration) : 0.0;
    float T3 = (Stage_Count >= 3) ? max(1e-4, Stage3_Duration) : 0.0;
    float Ttotal = T1 + T2 + T3;

    // 3) Determine time position within the whole cycle (loop vs one-shot)
    float t01;
    if (One_Shot) {
        float t = max(0.0, TIME - OneShot_Delay);
        t01 = clamp(t / Ttotal, 0.0, 1.0);
    } else {
        t01 = fract(Phase_Offset + TIME / Ttotal);
    }
    float tsec = t01 * Ttotal;

    // One-shot finished → output base only
    if (One_Shot && t01 >= 1.0) {
        vec3 out_rgb = base.rgb * base.a; // premultiply
        COLOR = vec4(out_rgb, base.a);

    }

    // 4) Determine current stage, local time, and duration
    int   stage   = 1;
    float t_local = tsec;
    float T_stage = T1;

    if (Stage_Count >= 2 && tsec >= T1 && tsec < T1 + T2) {
        stage   = 2;
        t_local = tsec - T1;
        T_stage = T2;
    } else if (Stage_Count >= 3 && tsec >= T1 + T2) {
        stage   = 3;
        t_local = tsec - (T1 + T2);
        T_stage = T3;
    }

    // 5) Normalized progress within the current stage (0..1)
    float p = clamp(t_local / T_stage, 0.0, 1.0);

    // 6) Effective angle (base ± wiggle tied to stage progress)
    // Wiggle curve is sin(pi*(2p-1)) so it starts/ends at 0 and peaks in the middle.
    float angle_eff_deg = Angle_deg;
    if (Wiggle_Angle) {
        float wig = sin(3.14159265 * (2.0 * p - 1.0)); // [-1..1], 0 at edges, ±1 at center
        angle_eff_deg += Wiggle_Amount_deg * wig;
    }

    // 7) Rotated UVs with effective angle
    float a = radians(angle_eff_deg);
    vec2  ruv = rotate_uv(UV, vec2(0.5), angle_eff_deg);

    // 8) Rotated sprite horizontal footprint (in rotated space along ruv.x)
    float c = abs(cos(a));
    float s = abs(sin(a));
    float min_x = 0.5 - 0.5 * (c + s);
    float max_x = 0.5 + 0.5 * (c + s);

    // 9) Per-stage width & direction
    float width = Stage1_Width;
    bool  dir_now = Stage1_LeftToRight;
    if (stage == 2) { width = Stage2_Width; dir_now = Stage2_LeftToRight; }
    else if (stage == 3) { width = Stage3_Width; dir_now = Stage3_LeftToRight; }

    float half_w = max(width * 0.5, 1e-4);

    // Feather (hard edges if Band_Soft == 0.0)
    float soft_raw = Band_Soft;
    float soft     = max(Band_Soft, 1e-5); // avoid zero in smoothstep edges

    // Padding ensures the band starts & ends fully off the sprite for this stage
    float pad = half_w + soft; // increase slightly (e.g., *1.05) if you ever see tiny residuals

    // Offscreen→offscreen sweep bounds for this stage
    float start_x = min_x - pad;
    float end_x   = max_x + pad;

    // 10) Sweep center position (off→off)
    float center = dir_now ? mix(start_x, end_x, p) : mix(end_x, start_x, p);

    // 11) Distance from band center → mask
    float d = abs(ruv.x - center);

    float band;
    if (soft_raw <= 0.0) {
        band = step(d, half_w);   // crisp hard edge
    } else {
        band = 1.0 - smoothstep(half_w, half_w + soft, d);
    }

    // Apply only where the sprite is visible
    band *= base.a;

    // 12) Add white shine and premultiply for premul-alpha blending
    vec3 lit_rgb = base.rgb + vec3(1.0) * (band * Brightness);
    float out_a   = base.a;
    vec3  out_rgb = lit_rgb * out_a;

    COLOR = vec4(out_rgb, out_a);
}